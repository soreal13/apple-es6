<div></div>

<script>

// 상속 구현 방법 1.constructor 2.prototype
// prototype 이란 유전자 이다.
// constructor 만들면 prototype이라는 공간이 자동으로 생김.

function Student(name){
    this.name = name;
    this.age = 15;
    this.sayHi = function(){
        console.log(`안녕하세요 ${this.name} 입니다.`)
    }
}

Student.prototype.gender = '여';

var 학생1 = new Student('park');
var 학생2 = new Student('Yoon');


// prototype 동작원리
// 1. 학생1이 직접 gender 가지고 있는가?
// 2. 학생1의 부모 constructor가 gender 가지고 있나? -> 실행!
// 3. 그 부모의 부모의 유전자에 있나? 

// 내장함수는 어떻게 동작하는가

// 1. prototype은 함수에만 생성됨.
// 2. 내 부모 유전자(부모 prototpye) 검사하고 싶다면 __proto__

// 3. __proto__ 이용해 부모님 강제 등록하기
var 부모 = {name : 'kim'};
var 자식 = {};
자식.__proto__ = 부모;

// 4. 콘솔창에서 알려주는 prototype chain
// 자바스크립트는 모든게 다 Object


// 연습문제

// 0
function Hacksaeng(name, age) {
    this.name = name;
    this.age = age;
    this.sayHi = function(){
        console.log(`안녕 나는 ${this.name}이야`);
    }
}

// 1
function Parent(){
  this.name = 'Kim';
}
var a = new Parent();

a.__proto__.name = 'Park';
console.log(a.name)

// kim

// 2
function Student(이름, 나이){
  this.name = 이름;
  this.age = 나이;
}

Student.prototype.sayHi = () => {
    console.log('안녕 나는 ' + this.name + '이야');
  }
var 학생1 = new Student('Kim', 20);

학생1.sayHi(); //왜 이 코드가 제대로 안나오죠?


//안녕 나는 이야 나옴
// 모르겠음.... 
// -> this가 이상해서 나오는 문제
// arrow function은 그냥 일반 function 대체품이아님 
//arrow function은 this를 바깥에 있는 this를 그대로 사용하고 싶을 때 쓰는 함수
//외부 this 값을 가져온다.
// 바깥 this 값은 window 그 window를 그대로 저기 함수 안에다가 적용

/* 봐도봐도 헷갈리는 this와 arrow function

this 잠깐 복습하자면 0
함수안에서 this 키워드의 뜻은 매번 재정의됩니다. 0
object안에 들어있는 함수안에 있는 this는 함수를 부른 object가 된다고 했습니다.
하지만 arrow function의 경우 함수 안에서 this 뜻이 재정의되지 않고 바깥에 있던 this를 사용합니다. 

*/


//3
Array.prototype.remove3 = function() {
  for (var i=0; i<this.length; i++) {
    if (this[i] == 3) {
      this.splice(i, 1);
    }
  }
}



</script>


